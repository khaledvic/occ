.data
static_instance_1:    .byte   0:4
static_instance_2:    .byte   0:4
static_instance_3:    .byte   0:4

newline: .asciiz "\n"

.text
.globl main
main:
#common assemblies


 #reserving space in stack for scope variables
sub $sp,$sp,12
 ##F:code.txt #L:45
 #asm node :la $t0,static_instance_1
la $t0,static_instance_1

 ##F:code.txt #L:45
 #asm node :sw $t0,0($gp)
sw $t0,0($gp)

 ##F:code.txt #L:45
 #asm node :la $t0,static_instance_2
la $t0,static_instance_2

 ##F:code.txt #L:45
 #asm node :sw $t0,-4($gp)
sw $t0,-4($gp)

 ##F:code.txt #L:45
 #asm node :la $t0,static_instance_3
la $t0,static_instance_3

 ##F:code.txt #L:45
 #asm node :sw $t0,-8($gp)
sw $t0,-8($gp)

 ##F:code.txt #L:45
 #identifier wessam
lw $t0,-8($gp)
addi $v0,$gp,-8
sub $sp,$sp,4
sw $t0, 0($sp)
add $sp,$sp,4
 ##F:code.txt #L:45
 #asm node :sub $sp,$sp,4
sub $sp,$sp,4
 ##F:code.txt #L:45
 #asm node :jal _c4_method_1
jal _c4_method_1
 ##F:code.txt #L:45
 #asm node :li $v0,10
li $v0,10
 ##F:code.txt #L:45
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,12
 ##########################################
 #Generating code for class NSObject




 #vtable: 


vt_1:
 #super
 ##########################################
 ####STATIC
 ##########################################
 #Generating code for class NSObject




 #vtable: 


vt_5:
 #allocalloc
li $t0,2
beq $t0,$a1,_c5_method_2
 #super


 #generating code for Method:alloc

_c5_method_2:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:45
 #asm node :li $v0,9
li $v0,9
 ##F:code.txt #L:45
 #asm node :li $a0,4
li $a0,4
 ##F:code.txt #L:45
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra
 ##########################################



 ####End STATIC



 ##########################################
 #Generating code for class System




 #vtable: 


vt_2:
 #super
 #NSObject
 #super
 ##########################################
 ####STATIC
 ##########################################
 #Generating code for class System




 #vtable: 


vt_6:
 #print: (int) parameter 
li $t0,3
beq $t0,$a1,_c6_method_3
 #print: (float) parameter 
li $t0,4
beq $t0,$a1,_c6_method_4
 #print: (NSString) parameter 
li $t0,5
beq $t0,$a1,_c6_method_5
 #print: (char) parameter 
li $t0,6
beq $t0,$a1,_c6_method_6
 #allocalloc
li $t0,2
beq $t0,$a1,_c6_method_2
 #readcharreadchar
li $t0,7
beq $t0,$a1,_c6_method_7
 #readfloatreadfloat
li $t0,8
beq $t0,$a1,_c6_method_8
 #readintreadint
li $t0,9
beq $t0,$a1,_c6_method_9
 #readstringreadstring
li $t0,10
beq $t0,$a1,_c6_method_10
 #super


 #generating code for Method:print: (int) parameter 

_c6_method_3:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:26
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:27
 #asm node :li $v0 ,1
li $v0 ,1
 ##F:system.oc #L:28
 #asm node :lw $a0 ,-8($fp)
lw $a0 ,-8($fp)
 ##F:system.oc #L:29
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:print: (float) parameter 

_c6_method_4:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:32
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:33
 #asm node :li $v0, 2
li $v0, 2
 ##F:system.oc #L:34
 #asm node :l.s  $f12,-8($fp)
l.s  $f12,-8($fp)
 ##F:system.oc #L:35
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:print: (NSString) parameter 

_c6_method_5:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:38
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:39
 #asm node :li $v0 ,4
li $v0 ,4
 ##F:system.oc #L:40
 #asm node :lw $a0 ,-8($fp)
lw $a0 ,-8($fp)
 ##F:system.oc #L:41
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:print: (char) parameter 

_c6_method_6:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:44
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:45
 #asm node :li $v0, 12
li $v0, 12
 ##F:system.oc #L:46
 #asm node :lw $a0 ,-8($fp)
lw $a0 ,-8($fp)
 ##F:system.oc #L:47
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:alloc

_c6_method_2:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:45
 #asm node :li $v0,9
li $v0,9
 ##F:code.txt #L:45
 #asm node :li $a0,4
li $a0,4
 ##F:code.txt #L:45
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra


 #generating code for Method:readchar

_c6_method_7:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:69
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:71
 #asm node :li $v0,12
li $v0,12
 ##F:system.oc #L:72
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra


 #generating code for Method:readfloat

_c6_method_8:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:56
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:58
 #asm node :li $v0, 6
li $v0, 6
 ##F:system.oc #L:59
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra


 #generating code for Method:readint

_c6_method_9:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:50
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:52
 #asm node :li $v0, 5
li $v0, 5
 ##F:system.oc #L:53
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra


 #generating code for Method:readstring

_c6_method_10:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:62
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:64
 #asm node :li $v0,8
li $v0,8
 ##F:system.oc #L:65
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra
 ##########################################



 ####End STATIC



 ##########################################
 #Generating code for class wessam




 #vtable: 


vt_3:
 #go: (int) y 
li $t0,11
beq $t0,$a1,_c3_method_11
 #print: (int) parameter 
li $t0,3
beq $t0,$a1,_c3_method_3
 #a2go: (int) y 
li $t0,12
beq $t0,$a1,_c3_method_12
 #super
 #NSObject
 #super


 #generating code for Method:go: (int) y 

_c3_method_11:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:30
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:code.txt #L:31
 #Assign node
 #RHS:
li $t9,8
sub $sp,$sp,4
sw $t9, 0($sp)
 #Assign node lHS:
 #identifier y
lw $t0,-8($fp)
addi $v0,$fp,-8
sub $sp,$sp,4
sw $t0, 0($sp)
 #Assign node poping old val:
lw $t0, 0($sp)
add $sp,$sp,4
 #Assign node getting RHS val:
lw $t0, 0($sp)
 #Assign node storing in position val:
sw $t0,0($v0)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:print: (int) parameter 

_c3_method_3:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:14
 #reserving space in stack for scope variables
sub $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:a2go: (int) y 

_c3_method_12:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:36
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:38
 #releasing space in stack for scope variables
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra
 ##########################################
 ####STATIC
 ##########################################
 #Generating code for class wessam




 #vtable: 


vt_4:
 #print: (int) x 
li $t0,3
beq $t0,$a1,_c4_method_3
 #allocalloc
li $t0,2
beq $t0,$a1,_c4_method_2
 #mainmain
li $t0,1
beq $t0,$a1,_c4_method_1
 #super


 #generating code for Method:print: (int) x 

_c4_method_3:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:24
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:code.txt #L:25
 #CALLING A METHOD print: (int) parameter 
 #preserving registers
sub $sp,$sp,4
sw $ra, 0($sp)
sub $sp,$sp,4
sw $fp, 0($sp)
 #generating code for the sender
 #identifier System
lw $t0,-4($gp)
addi $v0,$gp,-4
sub $sp,$sp,4
sw $t0, 0($sp)
 #generating code for Args
 #generating code for selector:print
 #generating  for var #0
 #identifier x
lw $t0,-8($fp)
addi $v0,$fp,-8
sub $sp,$sp,4
sw $t0, 0($sp)
jal _c6_method_3
lw $fp, 0($sp)
add $sp,$sp,4
lw $ra, 0($sp)
add $sp,$sp,4
sub $sp,$sp,4
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8
jr $ra


 #generating code for Method:alloc

_c4_method_2:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:45
 #asm node :li $v0,9
li $v0,9
 ##F:code.txt #L:45
 #asm node :li $a0,4
li $a0,4
 ##F:code.txt #L:45
 #asm node :syscall
syscall
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra


 #generating code for Method:main

_c4_method_1:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:18
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:19
 ##F:code.txt #L:20
 #Assign node
 #RHS:
li $t9,2
sub $sp,$sp,4
sw $t9, 0($sp)
 #Assign node lHS:
 #identifier x
lw $t0,-8($fp)
addi $v0,$fp,-8
sub $sp,$sp,4
sw $t0, 0($sp)
 #Assign node poping old val:
lw $t0, 0($sp)
add $sp,$sp,4
 #Assign node getting RHS val:
lw $t0, 0($sp)
 #Assign node storing in position val:
sw $t0,0($v0)
add $sp,$sp,4
 ##F:code.txt #L:21
 #CALLING A METHOD print: (int) x 
 #preserving registers
sub $sp,$sp,4
sw $ra, 0($sp)
sub $sp,$sp,4
sw $fp, 0($sp)
 #generating code for the sender
 #identifier self
lw $t0,-4($fp)
addi $v0,$fp,-4
sub $sp,$sp,4
sw $t0, 0($sp)
 #generating code for Args
 #generating code for selector:print
 #generating  for var #0
 #CALLING A METHOD readint
 #preserving registers
sub $sp,$sp,4
sw $ra, 0($sp)
sub $sp,$sp,4
sw $fp, 0($sp)
 #generating code for the sender
 #identifier System
lw $t0,-4($gp)
addi $v0,$gp,-4
sub $sp,$sp,4
sw $t0, 0($sp)
 #generating code for Args
jal _c6_method_9
lw $fp, 0($sp)
add $sp,$sp,4
lw $ra, 0($sp)
add $sp,$sp,4
sub $sp,$sp,4
sw $v0, 0($sp)
jal _c4_method_3
lw $fp, 0($sp)
add $sp,$sp,4
lw $ra, 0($sp)
add $sp,$sp,4
sub $sp,$sp,4
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,4
jr $ra
 ##########################################



 ####End STATIC



