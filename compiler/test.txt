.globl main
main:
 ##########################################
 #Generating code for class NSObject




 ##########################################



 ##########################################
 #Generating code for class System






 #generating code for Method:print: (int) parameter 

_c1_method_1:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:26
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:27
 #asm node :li $v0 ,1
li $v0 ,1
add $sp,$sp,4
 ##F:system.oc #L:28
 #asm node :lw $a0 ,0($fp)
lw $a0 ,0($fp)
add $sp,$sp,4
 ##F:system.oc #L:29
 #asm node :syscall
syscall
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:print: (float) parameter 

_c1_method_2:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:32
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:33
 #asm node :li $v0, 2
li $v0, 2
add $sp,$sp,4
 ##F:system.oc #L:34
 #asm node :l.s  $f12,0($fp)
l.s  $f12,0($fp)
add $sp,$sp,4
 ##F:system.oc #L:35
 #asm node :syscall
syscall
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:print: (NSString) parameter 

_c1_method_3:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:38
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:39
 #asm node :li $v0 ,4
li $v0 ,4
add $sp,$sp,4
 ##F:system.oc #L:40
 #asm node :lw $a0 ,0($fp)
lw $a0 ,0($fp)
add $sp,$sp,4
 ##F:system.oc #L:41
 #asm node :syscall
syscall
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:print: (char) parameter 

_c1_method_4:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:system.oc #L:44
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:45
 #asm node :li $v0, 12
li $v0, 12
add $sp,$sp,4
 ##F:system.oc #L:46
 #asm node :lw $a0 ,0($fp)
lw $a0 ,0($fp)
add $sp,$sp,4
 ##F:system.oc #L:47
 #asm node :syscall
syscall
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:readcharreadchar

_c1_method_5:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:75
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:77
 #asm node :li $v0,12
li $v0,12
add $sp,$sp,4
 ##F:system.oc #L:78
 #asm node :syscall
syscall
add $sp,$sp,4
 ##F:system.oc #L:79
 #asm node :sub $sp,$sp,4
sub $sp,$sp,4
add $sp,$sp,4
 ##F:system.oc #L:80
 #asm node :sw $v0, 0($sp)
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4


 #generating code for Method:readfloatreadfloat

_c1_method_6:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:58
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:60
 #asm node :li $v0, 6
li $v0, 6
add $sp,$sp,4
 ##F:system.oc #L:61
 #asm node :syscall
syscall
add $sp,$sp,4
 ##F:system.oc #L:62
 #asm node :sub $sp,$sp,4
sub $sp,$sp,4
add $sp,$sp,4
 ##F:system.oc #L:63
 #asm node :sw $v0, 0($sp)
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4


 #generating code for Method:readintreadint

_c1_method_7:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:50
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:52
 #asm node :li $v0, 5
li $v0, 5
add $sp,$sp,4
 ##F:system.oc #L:53
 #asm node :syscall
syscall
add $sp,$sp,4
 ##F:system.oc #L:54
 #asm node :sub $sp,$sp,4
sub $sp,$sp,4
add $sp,$sp,4
 ##F:system.oc #L:55
 #asm node :sw $v0, 0($sp)
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4


 #generating code for Method:readstringreadstring

_c1_method_8:
 #moving the stack back because args are in scoop
add $sp,$sp,4
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:system.oc #L:66
 #reserving space in stack for scope variables
sub $sp,$sp,0
 ##F:system.oc #L:68
 #asm node :li $v0,8
li $v0,8
add $sp,$sp,4
 ##F:system.oc #L:69
 #asm node :syscall
syscall
add $sp,$sp,4
 ##F:system.oc #L:70
 #asm node :sub $sp,$sp,4
sub $sp,$sp,4
add $sp,$sp,4
 ##F:system.oc #L:71
 #asm node :sw $v0, 0($sp)
sw $v0, 0($sp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,4
 ##########################################



 ##########################################
 #Generating code for class wessam






 #generating code for Method:go: (int) y 

_c2_method_9:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:18
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:19
li $t9,8
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier y
lw $t9,4($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,4($fp)
add $sp,$sp,4
 ##F:code.txt #L:20
add $sp,$sp,4
 ##F:code.txt #L:21
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:22
add $sp,$sp,4
 ##F:code.txt #L:23
li $t9,3
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier mm
lw $t9,16($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,16($fp)
add $sp,$sp,4
 ##F:code.txt #L:24
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:25
add $sp,$sp,4
 ##F:code.txt #L:26
li $t9,0
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier y
lw $t9,4($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,4($fp)
add $sp,$sp,4
 ##F:code.txt #L:27
li $t9,0
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier c
lw $t9,8($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,8($fp)
add $sp,$sp,4
 ##F:code.txt #L:28
li $t9,0
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier bb
lw $t9,24($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,24($fp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,4
 ##F:code.txt #L:30
add $sp,$sp,4
 ##F:code.txt #L:31
li $t9,11
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier nn
lw $t9,20($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
sw $t0,20($fp)
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,8
 ##F:code.txt #L:33
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,8
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:print: (int) parameter 

_c2_method_1:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:14
 #reserving space in stack for scope variables
sub $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,0
 #releasing space in stack for scope variables
add $sp,$sp,8


 #generating code for Method:a2go: (int) y 

_c2_method_10:
 #moving the stack back because args are in scoop
add $sp,$sp,8
 #movesp to fp
move $fp,$sp
 #reserving space in stack for scope variables
sub $sp,$sp,8
 ##F:code.txt #L:38
 #reserving space in stack for scope variables
sub $sp,$sp,4
 ##F:code.txt #L:40
add $sp,$sp,4
 ##F:code.txt #L:41
 #identifier a
lw $t9,8($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
 #CALLING A METHOD go: (int) y 
 #generating code for the sender
 #identifier a
lw $t9,8($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
 #generating code for Args
 #generating code for selector:go
 #generating  for var #0
li $t9,5
sub $sp,$sp,4
sw $t9, 0($sp)
jal _c2_method_9
add $sp,$sp,4
 ##F:code.txt #L:42
li $t9,2
sub $sp,$sp,4
sw $t9, 0($sp)
lw $t1, 0($sp)
add $sp,$sp,4
 #identifier a
lw $t9,8($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
 #getting a datamember b of type int
 #generating code for the sender
 #identifier a
lw $t9,8($fp)
sub $sp,$sp,4
sw $t9, 0($sp)
lw $a0, 0($sp)
add $sp,$sp,4
lw $t0,4($a0)
sub $sp,$sp,4
sw $t0, 0($sp)
lw $t0, 0($sp)
add $sp,$sp,4
add $t0,$0,$t1
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,4
 #releasing space in stack for scope variables
add $sp,$sp,8
 ##########################################



